
pipeline {
    agent any

    environment {
        PATH="/Users/anirudhpathaneni/.pyenv/shims:/Users/anirudhpathaneni/.pyenv/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
        PYENV_ROOT="/Users/anirudhpathaneni/.pyenv"
        DOCKER_REGISTRY = "docker.io"
        DOCKER_USERNAME = "5unnysunny"
        DOCKER_CREDENTIALS_ID = "docker-hub-credentials"
        APP_VERSION = "1.0.${env.BUILD_NUMBER}"
        TEST_IMAGE_LIGHT = "healthcare-test-light:latest"
        TEST_IMAGE_ML = "healthcare-test-ml:latest"
        TEST_IMAGE_NODE = "healthcare-test-node:latest"
    }

    stages {
        stage('0. Build Test Images (if needed)') {
            steps {
                script {
                    // Build LIGHT test image (alert-engine, vitals-generator) - only if not exists
                    def lightExists = sh(script: "docker images -q ${TEST_IMAGE_LIGHT} 2>/dev/null", returnStdout: true).trim()
                    if (!lightExists) {
                        echo "Building light test image (first time only)..."
                        sh "docker build -t ${TEST_IMAGE_LIGHT} -f ci-cd/docker/Dockerfile.test-base-light ."
                    } else {
                        echo "Light test image already exists, skipping build."
                    }

                    // Build ML test image (summarizer-service) - only if not exists
                    def mlExists = sh(script: "docker images -q ${TEST_IMAGE_ML} 2>/dev/null", returnStdout: true).trim()
                    if (!mlExists) {
                        echo "Building ML test image (first time only - this may take a few minutes)..."
                        sh "docker build -t ${TEST_IMAGE_ML} -f ci-cd/docker/Dockerfile.test-base-ml ."
                    } else {
                        echo "ML test image already exists, skipping build."
                    }
                }
            }
        }

        stage('1. Checkout') {
            steps {
                script{
                    checkout scm
                }
            }
        }

        stage('2. Backend Unit Tests') {
            parallel {
                stage('Alert Engine Tests') {
                    steps {
                        dir('backend/alert-engine') {
                            // Use pre-built image - NO pip install needed!
                            sh 'docker run --rm -v $PWD:/app -w /app ${TEST_IMAGE_LIGHT} python -m pytest tests/ -v'
                        }
                    }
                }
                stage('Summarizer Service Tests') {
                    steps {
                        dir('backend/summarizer-service') {
                            // Use pre-built ML image - NO pip install needed!
                            sh 'docker run --rm -v $PWD:/app -w /app ${TEST_IMAGE_ML} python -m pytest tests/ -v'
                        }
                    }
                }
                stage('Vitals Generator Tests') {
                    steps {
                        dir('backend/vitals-generator') {
                            // Use pre-built image - NO pip install needed!
                            sh 'docker run --rm -v $PWD:/app -w /app ${TEST_IMAGE_LIGHT} python -m pytest tests/ -v'
                        }
                    }
                }
            }
        }

        // Frontend tests skipped - no test files configured


        stage('3. Build Frontend') {
            steps {
                dir('frontend') {
                    // Reuse npm cache, use npm ci for faster, reliable installs
                    sh 'docker run --rm -v $PWD:/app -v npm-cache:/root/.npm -w /app node:18 sh -c "npm ci --prefer-offline && npm run build"'
                }
            }
        }

        stage('4. Docker Build') {
            steps {
                script {
                    def backend_services = ['alert-engine', 'auth-service', 'summarizer-service', 'vitals-generator']
                    backend_services.each { service ->
                        dir("backend/${service}") {
                            sh "docker build -t ${DOCKER_REGISTRY}/${DOCKER_USERNAME}/${service}:${APP_VERSION} ."
                        }
                    }
                    dir("frontend") {
                        sh "docker build -t ${DOCKER_REGISTRY}/${DOCKER_USERNAME}/frontend:${APP_VERSION} ."
                    }
                }
            }
        }

        stage('5. Docker Push') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: DOCKER_CREDENTIALS_ID, usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh "echo ${DOCKER_PASS} | docker login ${DOCKER_REGISTRY} -u ${DOCKER_USER} --password-stdin"

                        def services_to_push = ['alert-engine', 'auth-service', 'summarizer-service', 'vitals-generator']

                        services_to_push.each { service ->
                            def imageName = "${DOCKER_REGISTRY}/${DOCKER_USERNAME}/${service}:${APP_VERSION}"
                            sh "docker push ${imageName}"
                        }

                        def frontendImageName = "${DOCKER_REGISTRY}/${DOCKER_USERNAME}/frontend:${APP_VERSION}"
                        sh "docker push ${frontendImageName}"
                    }
                }
            }
        }

        stage('6. Local Agent Cleanup') {
            steps {
                script {
                    sh 'chmod +x cleanup.sh'
                    sh './cleanup.sh ${DOCKER_USERNAME} ${APP_VERSION}'
                }
            }
        }

        stage('7. Docker Compose Integration Test') {
            steps {
                script {
                    try {
                        echo "Starting services for integration test..."
                        sh 'docker-compose -f docker-compose.yml up -d'

                        echo "Waiting for services to stabilize..."
                        sh 'sleep 10'

                        echo "Running deployment tests..."
                        sh 'chmod +x test-deployment.sh curl-test.sh logstash-test.sh network-check.sh'
                        sh './test-deployment.sh'
                    } finally {
                        echo "Tearing down integration test environment..."
                        sh 'docker-compose -f docker-compose.yml down --remove-orphans'
                    }
                }
            }
        }

        stage("DEBUG PATH") {
            steps {
                sh "echo PATH=\$PATH"
                sh "which ansible-playbook || echo 'ansible not found'"
                sh "which python3"
            }
        }
        
        stage('8. Deployment (Ansible)') {
            steps {
                dir('infrastructure/ansible') {
                    script {
                        // Initialize pyenv and run Ansible playbook
                        sh '''
                            # Initialize pyenv if present
                            export PYENV_ROOT="$HOME/.pyenv"
                            export PATH="$PYENV_ROOT/shims:$PYENV_ROOT/bin:$PATH"
                            if command -v pyenv &> /dev/null; then
                                eval "$(pyenv init -)"
                            fi

                            # Install Ansible if not present
                            which ansible-playbook || pip3 install ansible --quiet

                            export ANSIBLE_ROLES_PATH=./roles
                            ansible-playbook -i inventory/hosts playbooks/backend.yml
                        '''
                    }
                }
            }
        }

        stage('9. Post-Deployment Validation') {
            steps {
                script {
                    echo "Validating Kubernetes deployments..."
                    sh 'kubectl rollout status deployment/alert-engine -n healthcare --timeout=120s'
                    sh 'kubectl rollout status deployment/summarizer-service -n healthcare --timeout=120s'
                    sh 'kubectl rollout status deployment/vitals-generator -n healthcare --timeout=120s'
                    sh 'kubectl rollout status deployment/frontend -n healthcare --timeout=120s'
                    echo "All deployments validated successfully."
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline finished.'
            cleanWs()
        }
        success {
            mail to: 'your-email@example.com',
                 subject: "SUCCESS: ${env.JOB_NAME} - Build #${env.BUILD_NUMBER}",
                 body: "Pipeline finished successfully. Details: ${env.BUILD_URL}"
        }
        failure {
            mail to: 'your-email@example.com',
                 subject: "FAILURE: ${env.JOB_NAME} - Build #${env.BUILD_NUMBER}",
                 body: "Pipeline failed. Details: ${env.BUILD_URL}"
        }
    }
}
